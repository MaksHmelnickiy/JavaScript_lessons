// Шпаргалка по методам массива:

// Для добавления/удаления элементов:

// ⁡⁢⁣⁣push⁡ (...items) – добавляет элементы в конец,
// ⁡⁢⁣⁣pop()⁡ – извлекает элемент с конца,
// ⁡⁢⁣⁣shift()⁡ – извлекает элемент с начала,
// ⁡⁢⁣⁣unshift(...items)⁡ – добавляет элементы в начало.
// ⁡⁢⁣⁣splice(pos, deleteCount, ...items)⁡ – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
// ⁡⁢⁣⁣slice(start, end)⁡ – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
// ⁡⁢⁣⁣concat(...items)⁡ – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
// Для поиска среди элементов:

// ⁡⁢⁣⁣indexOf/lastIndexOf(item, pos)⁡ – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
// ⁡⁢⁣⁣includes(value)⁡ – возвращает true, если в массиве имеется элемент value, в противном случае false.
// ⁡⁢⁣⁣find/filter(func)⁡ – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
// ⁡⁢⁣⁣findIndex⁡ похож на ⁡⁢⁣⁣find⁡, но возвращает индекс вместо значения.
// Для перебора элементов:

// ⁡⁢⁣⁣forEach(func)⁡ – вызывает func для каждого элемента. Ничего не возвращает.
// Для преобразования массива:

// ⁡⁢⁣⁣map(func)⁡ – создаёт новый массив из результатов вызова func для каждого элемента.
// ⁡⁢⁣⁣sort(func)⁡ – сортирует массив «на месте», а потом возвращает его.
// ⁡⁢⁣⁣reverse()⁡ – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// ⁡⁢⁣⁣split/join⁡ – преобразует строку в массив и обратно.
// ⁡⁢⁣⁣reduce(func, initial)⁡ – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
// Дополнительно:

// ⁡⁢⁣⁣Array.isArray(arr)⁡ проверяет, является ли arr массивом.
// Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

// Изученных нами методов достаточно в 99% случаев, но существуют и другие.

// ⁡⁢⁣⁣arr.some(fn)/arr.every(fn)⁡ проверяет массив.
// Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.

// ⁡⁢⁣⁣arr.fill(value, start, end)⁡ – заполняет массив повторяющимися value, начиная с индекса start до end.

// ⁡⁢⁣⁣arr.copyWithin(target, start, end)⁡ – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).

// Полный список есть в справочнике MDN.
// На первый взгляд может показаться, что существует очень много разных методов, которые довольно сложно запомнить. Но это гораздо проще, чем кажется.

// Внимательно изучите шпаргалку, представленную выше, а затем, чтобы попрактиковаться, решите задачи, предложенные в данной главе. 
// Так вы получите необходимый опыт в правильном использовании методов массива.

// Всякий раз, когда вам будет необходимо что-то сделать с массивом, а вы не знаете, как это сделать – приходите сюда, смотрите на таблицу и ищите правильный метод. 
// Примеры помогут вам всё сделать правильно, и вскоре вы быстро запомните методы без особых усилий.

// ⁡⁣⁣⁢ЗАДАЧИ⁡ //

// ⁡⁣⁣⁢Task⁡ ⁡⁣⁣⁢N1⁡⁡ /
// Напишите функцию ⁡⁣⁢⁣camelize(str)⁡⁡, которая преобразует строки вида «⁡⁣⁣⁢my-short-string⁡» в «⁡⁣⁣⁢myShortString⁡».
function camelize(str) {
    let a = str.split('-')
    let b = a.map(function(item, index){
        if(index > 0){
            return item[0].toUpperCase() + item.slice(1) // Делаем первую букву ⁡⁣⁣⁢заглавной⁡, 
                                            // и добавляем остальную часть слова через ⁡⁢⁣⁣slice(1)⁡ где ⁡⁣⁢⁣1⁡ это индекс старта.
        }
        return item
    })
  return b.join('')
}
console.log('Task N1: ', camelize('list-style-type'))

// ⁡⁣⁣⁢Task N2⁡ /
// Напишите функцию ⁡⁣⁢⁡⁣⁢⁣filterRange(arr, a, b)⁡⁡, которая принимает массив arr, 
// ищет элементы со значениями больше или равными a и меньше или равными b и возвращает результат в виде массива.
// Функция должна возвращать новый массив и не изменять исходный.
let array = [14,6,11,22,5]
function filter(a,b, arr) {
    let c = arr.find(item => item >=a);
    let d = arr.find(item => item <= b);
    let newArr = [];
    newArr.push(c,d)
    return newArr
}
console.log(filter(15, 12, array))

// ⁡⁣⁣⁢Task N3⁡ /
// Напишите функцию ⁡⁣⁢⁣filterRange(arr, a, b)⁡, которая принимает массив arr, 
// ищет элементы со значениями больше или равными a и меньше или равными b и возвращает результат в виде массива.
// Функция должна возвращать новый массив и не изменять исходный.
let arrRange = [5,3,8,1];

function filterRange(arr,a,b){
    for(let i = 0; i < arr.length; i++){

        if(arr[i] < a || arr[i] > b){
            arr.splice(i,1)
        }
    }
}
filterRange(arrRange,1,4)
console.log('Task 3', arrRange)


// ⁡⁣⁣⁢Task N4⁡ /
// Сортировать в порядке по убыванию
let arrDimination = [3,11,4,-11,15];

arrDimination.sort(function(a,b){
    console.log(a + '===' + b)
    return b-a;
});
console.log('Task N4', arrDimination)


// ⁡⁣⁣⁢Task N5⁡ /
// У нас есть массив строк arr. Нужно получить отсортированную копию, но оставить arr неизменённым.
// Создайте функцию ⁡⁣⁢⁣copySorted(arr)⁡, которая будет возвращать такую копию.

let arrSort = ["HTML", "JavaScript", "CSS"];
function arrSortFunc(arr){
   return arr.slice().sort()
}
let sorted = arrSortFunc(arrSort)

console.log('Task N5', arrSort)


// ⁡⁣⁣⁢Task N6 ⁡/



